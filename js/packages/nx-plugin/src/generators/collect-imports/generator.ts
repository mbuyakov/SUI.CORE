import {readJson, Tree} from "@nx/devkit";
import {CollectImportsGeneratorSchema} from "./schema";
import {visitAllFiles, visitAllProjects} from "../../utils/visitors";
import {oldPackages} from "../../utils/oldPackages";
import {astQuery} from "@sui/lib-typescript-ast";
import {
  isClassDeclaration,
  isExportAssignment,
  isExportDeclaration,
  isFunctionDeclaration,
  isInterfaceDeclaration,
  isTypeAliasDeclaration,
  isVariableStatement,
  SyntaxKind
} from "typescript";
import {logWithPrefix, setSpinnerText} from "../../utils/logger";
import {importsByNewPackage} from "../sui-migrator/modules/support/remapOldPackages";
import {parseExportDeclaration} from "./modules/parseExportDeclaration";
import {parseVariableStatement} from "./modules/parseVariableStatement";
import {parseCommonNamedNode} from "./modules/parseCommonNamedNode";

const naturalSorter = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
const MAP_FILE_PATH = "packages/nx-plugin/src/generators/sui-migrator/modules/support/remapOldPackages.ts";
const newImportsByNewPackage: { [index: string]: string[] } = {};

function addExport(packageName: string, name: string) {
  if (!importsByNewPackage[packageName]?.includes(name)) {
    logWithPrefix("collectImport", `Add export ${name} from ${packageName}`);
  }
  newImportsByNewPackage[packageName] = newImportsByNewPackage[packageName] || [];
  newImportsByNewPackage[packageName].push(name);
}

export function collectImportsGenerator(tree: Tree, options: CollectImportsGeneratorSchema) {
  const content = tree.read(MAP_FILE_PATH).toString();
  visitAllProjects(tree, project => {
    const packageName = readJson(tree, `${project.root}/package.json`).name;

    if (project.name === "nx-plugin"
      // Don't parse old modules
      || oldPackages.includes(packageName)
    ) {
      return;
    }

    visitAllFiles(tree, project.sourceRoot, filePath => {
      if (
        (
          !filePath.endsWith(".ts")
          && !filePath.endsWith(".tsx")
        )
        || filePath.includes(".stories.")
      ) {
        return;
      }

      const content = tree.read(filePath).toString();
      const imports: string[] = [];

      if (!content.includes("export") || content.includes("SKIP_IMPORT_COLLECTING")) {
        return;
      }

      astQuery(content, "ExportKeyword").forEach(it => {
        it = it.parent;

        if (isExportAssignment(it)) {
          return;
        } else if (isExportDeclaration(it)) {
          imports.push(...parseExportDeclaration(it));
        } else if (isVariableStatement(it)) {
          imports.push(...parseVariableStatement(it));
        } else if (isFunctionDeclaration(it) || isTypeAliasDeclaration(it) || isClassDeclaration(it) || isInterfaceDeclaration(it)) {
          imports.push(parseCommonNamedNode(it));
        } else {
          throw new Error(`unknown parent type ${SyntaxKind[it.kind]} from ${filePath}`);
        }
      });
      imports.forEach(it => addExport(packageName, it));
    });

    setSpinnerText("common");
    importsByNewPackage[packageName]?.forEach(it => {
      if (!newImportsByNewPackage[packageName]?.includes(it)) {
        // language=text format=false
        logWithPrefix("collectImport", `Delete export ${it} from ${packageName}`);
      }
    });
  });

  Object.keys(newImportsByNewPackage).forEach(it => {
    newImportsByNewPackage[it].sort(naturalSorter);
  });

  const newContent = `
///////////////////////////////////
//FILE IS AUTOGENERATED. DON'T EDIT
///////////////////////////////////
export const importsByNewPackage = ${JSON.stringify(newImportsByNewPackage, Object.keys(newImportsByNewPackage).sort(), 2)};
  `.trim() + "\n";


  if (content != newContent) {
    tree.write(MAP_FILE_PATH, newContent);
  }
}

export default collectImportsGenerator;
